const tailwindPalettess = {
  red: {
    50: 'oklch(0.971 0.013 17.38)',
    100: 'oklch(0.936 0.032 17.717)',
    200: 'oklch(0.885 0.062 18.334)',
    300: 'oklch(0.808 0.114 19.571)',
    400: 'oklch(0.704 0.191 22.216)',
    500: 'oklch(0.637 0.237 25.331)',
    600: 'oklch(0.577 0.245 27.325)',
    700: 'oklch(0.505 0.213 27.518)',
    800: 'oklch(0.444 0.177 26.899)',
    900: 'oklch(0.396 0.141 25.723)',
    950: 'oklch(0.258 0.092 26.042)',
  },
  orange: {
    50: 'oklch(0.98 0.016 73.684)',
    100: 'oklch(0.954 0.038 75.164)',
    200: 'oklch(0.901 0.076 70.697)',
    300: 'oklch(0.837 0.128 66.29)',
    400: 'oklch(0.75 0.183 55.934)',
    500: 'oklch(0.705 0.213 47.604)',
    600: 'oklch(0.646 0.222 41.116)',
    700: 'oklch(0.553 0.195 38.402)',
    800: 'oklch(0.47 0.157 37.304)',
    900: 'oklch(0.408 0.123 38.172)',
    950: 'oklch(0.266 0.079 36.259)',
  },
  amber: {
    50: 'oklch(0.987 0.022 95.277)',
    100: 'oklch(0.962 0.059 95.617)',
    200: 'oklch(0.924 0.12 95.746)',
    300: 'oklch(0.879 0.169 91.605)',
    400: 'oklch(0.828 0.189 84.429)',
    500: 'oklch(0.769 0.188 70.08)',
    600: 'oklch(0.666 0.179 58.318)',
    700: 'oklch(0.555 0.163 48.998)',
    800: 'oklch(0.473 0.137 46.201)',
    900: 'oklch(0.414 0.112 45.904)',
    950: 'oklch(0.279 0.077 45.635)',
  },
  yellow: {
    50: 'oklch(0.987 0.026 102.212)',
    100: 'oklch(0.973 0.071 103.193)',
    200: 'oklch(0.945 0.129 101.54)',
    300: 'oklch(0.905 0.182 98.111)',
    400: 'oklch(0.852 0.199 91.936)',
    500: 'oklch(0.795 0.184 86.047)',
    600: 'oklch(0.681 0.162 75.834)',
    700: 'oklch(0.554 0.135 66.442)',
    800: 'oklch(0.476 0.114 61.907)',
    900: 'oklch(0.421 0.095 57.708)',
    950: 'oklch(0.286 0.066 53.813)',
  },
  lime: {
    50: 'oklch(0.986 0.031 120.757)',
    100: 'oklch(0.967 0.067 122.328)',
    200: 'oklch(0.938 0.127 124.321)',
    300: 'oklch(0.897 0.196 126.665)',
    400: 'oklch(0.841 0.238 128.85)',
    500: 'oklch(0.768 0.233 130.85)',
    600: 'oklch(0.648 0.2 131.684)',
    700: 'oklch(0.532 0.157 131.589)',
    800: 'oklch(0.453 0.124 130.933)',
    900: 'oklch(0.405 0.101 131.063)',
    950: 'oklch(0.274 0.072 132.109)',
  },
  green: {
    50: 'oklch(0.982 0.018 155.826)',
    100: 'oklch(0.962 0.044 156.743)',
    200: 'oklch(0.925 0.084 155.995)',
    300: 'oklch(0.871 0.15 154.449)',
    400: 'oklch(0.792 0.209 151.711)',
    500: 'oklch(0.723 0.219 149.579)',
    600: 'oklch(0.627 0.194 149.214)',
    700: 'oklch(0.527 0.154 150.069)',
    800: 'oklch(0.448 0.119 151.328)',
    900: 'oklch(0.393 0.095 152.535)',
    950: 'oklch(0.266 0.065 152.934)',
  },
  emerald: {
    50: 'oklch(0.979 0.021 166.113)',
    100: 'oklch(0.95 0.052 163.051)',
    200: 'oklch(0.905 0.093 164.15)',
    300: 'oklch(0.845 0.143 164.978)',
    400: 'oklch(0.765 0.177 163.223)',
    500: 'oklch(0.696 0.17 162.48)',
    600: 'oklch(0.596 0.145 163.225)',
    700: 'oklch(0.508 0.118 165.612)',
    800: 'oklch(0.432 0.095 166.913)',
    900: 'oklch(0.378 0.077 168.94)',
    950: 'oklch(0.262 0.051 172.552)',
  },
  teal: {
    50: 'oklch(0.984 0.014 180.72)',
    100: 'oklch(0.953 0.051 180.801)',
    200: 'oklch(0.91 0.096 180.426)',
    300: 'oklch(0.855 0.138 181.071)',
    400: 'oklch(0.777 0.152 181.912)',
    500: 'oklch(0.704 0.14 182.503)',
    600: 'oklch(0.6 0.118 184.704)',
    700: 'oklch(0.511 0.096 186.391)',
    800: 'oklch(0.437 0.078 188.216)',
    900: 'oklch(0.386 0.063 188.416)',
    950: 'oklch(0.277 0.046 192.524)',
  },
  cyan: {
    50: 'oklch(0.984 0.019 200.873)',
    100: 'oklch(0.956 0.045 203.388)',
    200: 'oklch(0.917 0.08 205.041)',
    300: 'oklch(0.865 0.127 207.078)',
    400: 'oklch(0.789 0.154 211.53)',
    500: 'oklch(0.715 0.143 215.221)',
    600: 'oklch(0.609 0.126 221.723)',
    700: 'oklch(0.52 0.105 223.128)',
    800: 'oklch(0.45 0.085 224.283)',
    900: 'oklch(0.398 0.07 227.392)',
    950: 'oklch(0.302 0.056 229.695)',
  },
  sky: {
    50: 'oklch(0.977 0.013 236.62)',
    100: 'oklch(0.951 0.026 236.824)',
    200: 'oklch(0.901 0.058 230.902)',
    300: 'oklch(0.828 0.111 230.318)',
    400: 'oklch(0.746 0.16 232.661)',
    500: 'oklch(0.685 0.169 237.323)',
    600: 'oklch(0.588 0.158 241.966)',
    700: 'oklch(0.5 0.134 242.749)',
    800: 'oklch(0.443 0.11 240.79)',
    900: 'oklch(0.391 0.09 240.876)',
    950: 'oklch(0.293 0.066 243.157)',
  },
  blue: {
    50: 'oklch(0.97 0.014 254.604)',
    100: 'oklch(0.932 0.032 255.585)',
    200: 'oklch(0.882 0.059 254.128)',
    300: 'oklch(0.809 0.105 251.813)',
    400: 'oklch(0.707 0.165 254.624)',
    500: 'oklch(0.623 0.214 259.815)',
    600: 'oklch(0.546 0.245 262.881)',
    700: 'oklch(0.488 0.243 264.376)',
    800: 'oklch(0.424 0.199 265.638)',
    900: 'oklch(0.379 0.146 265.522)',
    950: 'oklch(0.282 0.091 267.935)',
  },
  indigo: {
    50: 'oklch(0.962 0.018 272.314)',
    100: 'oklch(0.93 0.034 272.788)',
    200: 'oklch(0.87 0.065 274.039)',
    300: 'oklch(0.785 0.115 274.713)',
    400: 'oklch(0.673 0.182 276.935)',
    500: 'oklch(0.585 0.233 277.117)',
    600: 'oklch(0.511 0.262 276.966)',
    700: 'oklch(0.457 0.24 277.023)',
    800: 'oklch(0.398 0.195 277.366)',
    900: 'oklch(0.359 0.144 278.697)',
    950: 'oklch(0.257 0.09 281.288)',
  },
  violet: {
    50: 'oklch(0.969 0.016 293.756)',
    100: 'oklch(0.943 0.029 294.588)',
    200: 'oklch(0.894 0.057 293.283)',
    300: 'oklch(0.811 0.111 293.571)',
    400: 'oklch(0.702 0.183 293.541)',
    500: 'oklch(0.606 0.25 292.717)',
    600: 'oklch(0.541 0.281 293.009)',
    700: 'oklch(0.491 0.27 292.581)',
    800: 'oklch(0.432 0.232 292.759)',
    900: 'oklch(0.38 0.189 293.745)',
    950: 'oklch(0.283 0.141 291.089)',
  },
  purple: {
    50: 'oklch(0.977 0.014 308.299)',
    100: 'oklch(0.946 0.033 307.174)',
    200: 'oklch(0.902 0.063 306.703)',
    300: 'oklch(0.827 0.119 306.383)',
    400: 'oklch(0.714 0.203 305.504)',
    500: 'oklch(0.627 0.265 303.9)',
    600: 'oklch(0.558 0.288 302.321)',
    700: 'oklch(0.496 0.265 301.924)',
    800: 'oklch(0.438 0.218 303.724)',
    900: 'oklch(0.381 0.176 304.987)',
    950: 'oklch(0.291 0.149 302.717)',
  },
  fuchsia: {
    50: 'oklch(0.977 0.017 320.058)',
    100: 'oklch(0.952 0.037 318.852)',
    200: 'oklch(0.903 0.076 319.62)',
    300: 'oklch(0.833 0.145 321.434)',
    400: 'oklch(0.74 0.238 322.16)',
    500: 'oklch(0.667 0.295 322.15)',
    600: 'oklch(0.591 0.293 322.896)',
    700: 'oklch(0.518 0.253 323.949)',
    800: 'oklch(0.452 0.211 324.591)',
    900: 'oklch(0.401 0.17 325.612)',
    950: 'oklch(0.293 0.136 325.661)',
  },
  pink: {
    50: 'oklch(0.971 0.014 343.198)',
    100: 'oklch(0.948 0.028 342.258)',
    200: 'oklch(0.899 0.061 343.231)',
    300: 'oklch(0.823 0.12 346.018)',
    400: 'oklch(0.718 0.202 349.761)',
    500: 'oklch(0.656 0.241 354.308)',
    600: 'oklch(0.592 0.249 0.584)',
    700: 'oklch(0.525 0.223 3.958)',
    800: 'oklch(0.459 0.187 3.815)',
    900: 'oklch(0.408 0.153 2.432)',
    950: 'oklch(0.284 0.109 3.907)',
  },
  rose: {
    50: 'oklch(0.969 0.015 12.422)',
    100: 'oklch(0.941 0.03 12.58)',
    200: 'oklch(0.892 0.058 10.001)',
    300: 'oklch(0.81 0.117 11.638)',
    400: 'oklch(0.712 0.194 13.428)',
    500: 'oklch(0.645 0.246 16.439)',
    600: 'oklch(0.586 0.253 17.585)',
    700: 'oklch(0.514 0.222 16.935)',
    800: 'oklch(0.455 0.188 13.697)',
    900: 'oklch(0.41 0.159 10.272)',
    950: 'oklch(0.271 0.105 12.094)',
  },
  stone: {
    50: 'oklch(0.985 0.001 106.423)',
    100: 'oklch(0.97 0.001 106.424)',
    200: 'oklch(0.923 0.003 48.717)',
    300: 'oklch(0.869 0.005 56.366)',
    400: 'oklch(0.709 0.01 56.259)',
    500: 'oklch(0.553 0.013 58.071)',
    600: 'oklch(0.444 0.011 73.639)',
    700: 'oklch(0.374 0.01 67.558)',
    800: 'oklch(0.268 0.007 34.298)',
    900: 'oklch(0.216 0.006 56.043)',
    950: 'oklch(0.147 0.004 49.25)',
  },
  neutral: {
    50: 'oklch(0.985 0 0)',
    100: 'oklch(0.97 0 0)',
    200: 'oklch(0.922 0 0)',
    300: 'oklch(0.87 0 0)',
    400: 'oklch(0.708 0 0)',
    500: 'oklch(0.556 0 0)',
    600: 'oklch(0.439 0 0)',
    700: 'oklch(0.371 0 0)',
    800: 'oklch(0.269 0 0)',
    900: 'oklch(0.205 0 0)',
    950: 'oklch(0.145 0 0)',
  },
  zinc: {
    50: 'oklch(0.985 0 0)',
    100: 'oklch(0.967 0.001 286.375)',
    200: 'oklch(0.92 0.004 286.32)',
    300: 'oklch(0.871 0.006 286.286)',
    400: 'oklch(0.705 0.015 286.067)',
    500: 'oklch(0.552 0.016 285.938)',
    600: 'oklch(0.442 0.017 285.786)',
    700: 'oklch(0.37 0.013 285.805)',
    800: 'oklch(0.274 0.006 286.033)',
    900: 'oklch(0.21 0.006 285.885)',
    950: 'oklch(0.141 0.005 285.823)',
  },
  gray: {
    50: 'oklch(0.985 0.002 247.839)',
    100: 'oklch(0.967 0.003 264.542)',
    200: 'oklch(0.928 0.006 264.531)',
    300: 'oklch(0.872 0.01 258.338)',
    400: 'oklch(0.707 0.022 261.325)',
    500: 'oklch(0.551 0.027 264.364)',
    600: 'oklch(0.446 0.03 256.802)',
    700: 'oklch(0.373 0.034 259.733)',
    800: 'oklch(0.278 0.033 256.848)',
    900: 'oklch(0.21 0.034 264.665)',
    950: 'oklch(0.13 0.028 261.692)',
  },
  slate: {
    50: 'oklch(0.984 0.003 247.858)',
    100: 'oklch(0.968 0.007 247.896)',
    200: 'oklch(0.929 0.013 255.508)',
    300: 'oklch(0.869 0.022 252.894)',
    400: 'oklch(0.704 0.04 256.788)',
    500: 'oklch(0.554 0.046 257.417)',
    600: 'oklch(0.446 0.043 257.281)',
    700: 'oklch(0.372 0.044 257.287)',
    800: 'oklch(0.279 0.041 260.031)',
    900: 'oklch(0.208 0.042 265.755)',
    950: 'oklch(0.129 0.042 264.695)',
  },
};
function hexToOklch(hex) {
  // If input is already in oklch(...) format, parse and return [L, C, h]
  if (typeof hex === 'string' && hex.startsWith('oklch(')) {
    const match = hex.match(/oklch\(([^)]+)\)/);
    if (match) {
      const [l, c, h] = match[1].split(/\s+/).map(Number);
      // No conversion here, keep hue in degrees everywhere
      return [l, c, h];
    }
  }
  // Convert hex to linear sRGB
  function hexToLinearSRGB(h) {
    let r = parseInt(h.slice(1, 3), 16) / 255;
    let g = parseInt(h.slice(3, 5), 16) / 255;
    let b = parseInt(h.slice(5, 7), 16) / 255;

    function toLinear(c) {
      return c <= 0.04045 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
    }

    return [toLinear(r), toLinear(g), toLinear(b)];
  }

  // Convert linear sRGB to XYZ (D65)
  function linearSRGBToXYZ([r, g, b]) {
    return [
      r * 0.4122214708 + g * 0.5363325363 + b * 0.0514459929,
      r * 0.2119034982 + g * 0.6806995451 + b * 0.1073969566,
      r * 0.0883024619 + g * 0.2817188376 + b * 0.6299787005,
    ];
  }

  // Convert XYZ to Oklab
  function xyzToOklab([x, y, z]) {
    let l_ = Math.cbrt(0.8189330101 * x + 0.3618667424 * y - 0.1288597137 * z);
    let m_ = Math.cbrt(0.0329845436 * x + 0.9293118715 * y + 0.0361456387 * z);
    let s_ = Math.cbrt(0.0482003018 * x + 0.2643662691 * y + 0.633851707 * z);

    let L = 0.2104542553 * l_ + 0.793617785 * m_ - 0.0040720468 * s_;
    let a = 1.9779984951 * l_ - 2.428592205 * m_ + 0.4505937099 * s_;
    let b = 0.0259040371 * l_ + 0.7827717662 * m_ - 0.808675766 * s_;

    return [L, a, b];
  }

  // Convert Oklab to Oklch
  function oklabToOklch([L, a, b]) {
    let C = Math.sqrt(a * a + b * b);
    let h = Math.atan2(b, a) * (180 / Math.PI);
    if (h < 0) h += 360;
    // No rounding here; keep full precision for accuracy.
    return [L, C, h];
  }

  let linear = hexToLinearSRGB(hex);
  let xyz = linearSRGBToXYZ(linear);
  let oklab = xyzToOklab(xyz);
  return oklabToOklch(oklab);
}

function oklchToHex(color) {
  // Convert Oklch to Oklab
  function oklchToOklab([L, C, h]) {
    // h is in degrees, convert to radians
    let hRad = (h * Math.PI) / 180;
    return [L, C * Math.cos(hRad), C * Math.sin(hRad)];
  }

  // Convert Oklab to XYZ
  function oklabToXyz([L, a, b]) {
    let l_ = Math.pow(L + 0.3963377774 * a + 0.2158037573 * b, 3);
    let m_ = Math.pow(L - 0.1055613458 * a - 0.0638541728 * b, 3);
    let s_ = Math.pow(L - 0.0894841775 * a - 1.291485548 * b, 3);

    let x = +1.2270138511 * l_ - 0.5577999807 * m_ + 0.281256149 * s_;
    let y = -0.0405801784 * l_ + 1.1122568696 * m_ - 0.0716766787 * s_;
    let z = -0.0763812845 * l_ - 0.4214819784 * m_ + 1.5861632204 * s_;

    return [x, y, z];
  }

  // Convert XYZ to linear sRGB
  function xyzToLinearSRGB([x, y, z]) {
    return [
      +3.2409699419 * x - 1.5373831776 * y - 0.4986107603 * z,
      -0.9692436363 * x + 1.8759675015 * y + 0.0415550574 * z,
      +0.0556300797 * x - 0.2039769589 * y + 1.0569715142 * z,
    ];
  }

  // Convert linear sRGB to sRGB
  function linearToSRGB(c) {
    return c <= 0.0031308 ? 12.92 * c : 1.055 * Math.pow(c, 1 / 2.4) - 0.055;
  }

  let [L, C, h] = color;
  let oklab = oklchToOklab([L, C, h]);
  let xyz = oklabToXyz(oklab);
  let linearRGB = xyzToLinearSRGB(xyz);
  let srgb = linearRGB.map(linearToSRGB);

  // Clamp and convert to 0-255
  let r = Math.round(Math.min(Math.max(0, srgb[0]), 1) * 255);
  let g = Math.round(Math.min(Math.max(0, srgb[1]), 1) * 255);
  let b = Math.round(Math.min(Math.max(0, srgb[2]), 1) * 255);

  function toHex2(n) {
    return n.toString(16).padStart(2, '0');
  }

  return `#${toHex2(r)}${toHex2(g)}${toHex2(b)}`;
}

// Helper to compute cyclic hue difference (in degrees)
function hueDiff(h1, h2) {
  let d = Math.abs(h1 - h2);
  return d > 180 ? 360 - d : d;
}

// Generate Tailwind scale from base hex with palette matching and offset application
function generateTailwindScale(
  baseHex,
  steps = 10,
  lightnessRange = [0.95, 0.05]
) {
  console.log('🔥 generateTailwindScale start', baseHex);
  // Convert base color to Oklch
  const baseOklch = hexToOklch(baseHex);
  console.log(
    '🎯 DEBUG baseOklch (validated externally):',
    baseHex,
    '→',
    baseOklch
  );
  const baseL = baseOklch[0];
  const baseC = baseOklch[1];
  const baseH = baseOklch[2]; // hue in degrees

  // Tailwind steps keys as strings
  const stepKeys = [
    '50',
    '100',
    '200',
    '300',
    '400',
    '500',
    '600',
    '700',
    '800',
    '900',
    '950',
  ];

  // Find closest matching palette (by C and H only, ignoring L)
  let closest = {
    palette: null,
    step: null,
    distance: Infinity,
    paletteOklch: null,
  };

  for (const paletteName in tailwindPalettes) {
    console.log('📘 STARTING CHECK palette:', paletteName);
    const palette = tailwindPalettes[paletteName];
    // Compute average (or median) C and H for the palette, or check all steps for closest C/H to base
    for (const step of stepKeys) {
      if (!(step in palette)) continue;
      const hex = palette[step];
      if (!hex) continue;
      const oklch = hexToOklch(hex);
      // Only compare C and H (ignore L)
      const dC = baseC - oklch[1];
      const dH = hueDiff(baseH, oklch[2]);
      const dist = Math.sqrt(dC * dC + dH * dH);
      console.log(
        `📊 [PALETTE MATCH] ΔC: ${dC.toFixed(4)}, ΔH: ${dH.toFixed(
          2
        )}, Dist: ${dist.toFixed(4)} for ${paletteName} ${step}`
      );
      if (dist < closest.distance) {
        closest = {
          palette: paletteName,
          step: step, // temporary, will reselect step below
          distance: dist,
          paletteOklch: oklch,
        };
        console.log(
          '✅ NEW CLOSEST PALETTE:',
          paletteName,
          'at step',
          step,
          '→',
          oklchToHex(oklch),
          oklch
        );
      }
    }
  }

  // After closest palette is found, select step by L (lightness) only
  if (closest.palette) {
    const palette = tailwindPalettes[closest.palette];
    let closestStep = stepKeys.reduce((closestKey, key) => {
      const oklch = hexToOklch(palette[key]);
      const diff = Math.abs(baseL - oklch[0]);
      if (
        closestKey === null ||
        diff < Math.abs(baseL - hexToOklch(palette[closestKey])[0])
      ) {
        return key;
      }
      return closestKey;
    }, null);
    closest.step = closestStep;
  }

  // If no match found, fallback to generating scale normally
  if (!closest.palette) {
    // Fallback: generate scale from base color linearly interpolating lightness
    const [Lmin, Lmax] = lightnessRange;
    const scale = {};
    for (let i = 0; i < steps; i++) {
      const t = i / (steps - 1);
      const L = Lmax + t * (Lmin - Lmax);
      const C = baseC;
      const h = baseH;
      const color = [L, C, h];
      const hex = oklchToHex(color);
      const key = `--primary-color-${stepKeys[i] || 50 + i * 100}`;
      scale[key] = hex;
    }
    return scale;
  }

  // --- Compute reference deltas based on matched step index in reference palette ---
  const palette = tailwindPalettes[closest.palette];
  const matchedStepIndex = stepKeys.indexOf(closest.step);
  // Use fallback for missing palette steps
  const paletteOklchs = stepKeys.map((k) => {
    const oklchStr = palette[k];
    return oklchStr ? hexToOklch(oklchStr) : [baseL, baseC, baseH];
  });
  const refL = paletteOklchs[matchedStepIndex][0];
  const refC = paletteOklchs[matchedStepIndex][1];
  // refH in degrees
  const refH = paletteOklchs[matchedStepIndex][2];
  // Compute delta lists for each step in reference palette (L, C, H - ref)
  const deltaLList = paletteOklchs.map(([L]) => L - refL);
  const deltaCList = paletteOklchs.map(([, C]) => C - refC);
  const deltaHList = paletteOklchs.map(([, , H]) => {
    let d = H - refH;
    if (d > 180) d -= 360;
    else if (d < -180) d += 360;
    return d;
  });
  console.log('Matched palette:', closest.palette);
  console.log('Matched step:', closest.step);
  // Generate scale by applying reference deltas to base color
  const result = {};
  // Use all stepKeys to ensure all Tailwind keys (including '950') are included
  const keysToUse = stepKeys;
  for (let i = 0; i < keysToUse.length; i++) {
    const key = keysToUse[i];
    // palette[key] should always exist, but check for safety
    const hex = palette[key];
    if (!hex) continue;
    // At the matched step, use the original baseHex color and oklch
    if (key === closest.step) {
      result[`--primary-color-${key}`] = {
        hex: baseHex,
        oklch: baseOklch,
      };
      continue;
    }
    // Instead of using palette color, use reference palette L and C directly, and apply hue delta
    let newL = paletteOklchs[i][0]; // Use reference palette L directly
    let newC = paletteOklchs[i][1]; // Use chroma from the reference palette directly
    let newH = baseH + deltaHList[i];
    // Normalize newH to [0, 360)
    if (newH < 0) newH += 360;
    else if (newH >= 360) newH -= 360;
    // Clamp lightness and chroma to valid ranges
    newL = Math.min(Math.max(0, newL), 1);
    newC = Math.max(0, newC);
    const newHex = oklchToHex([newL, newC, newH]);
    result[`--primary-color-${key}`] = {
      hex: newHex,
      oklch: [newL, newC, newH],
    };
  }

  console.log('🎯 FINAL MATCHED:', closest.palette, closest.step);
  return result;
}

// Make the function globally available for browser console usage, even with type="module"
window.generateTailwindScale = generateTailwindScale;
